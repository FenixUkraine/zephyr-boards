/*
 * Copyright (c) 2023 Nuvoton Technology Corporation.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


#include <st/h5/stm32h563Xi.dtsi>
#include <st/h5/stm32h563vgtx-pinctrl.dtsi>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/dt-bindings/memory-attr/memory-attr.h>
#include <zephyr/dt-bindings/memory-attr/memory-attr-arm.h>

// #include <nuvoton/m2354.dtsi>
// // #include "fxa500_02-pinctrl.dtsi"
// #include <zephyr/dt-bindings/input/input-event-codes.h>

/ {
	model = "Fenix FXA500-03 board";
	compatible = "st,stm32h563";

	aliases {
		led0 = &out_led;
		// sw0 = &user_button_1;
		// sw1 = &user_button_2;
		// modem-uart = &usart3;		// WTF? Це дійсно треба?
		// modem = &modem;
		atmodem = &atmodem;
		accel0 = &lis2dw12;
		// adc0 = &eadc;

		// analog-inputs = &analog_inputs0;
		v12v = &v12v;
		// shake-sensor = &shake_sensor;
		// accelerometer = &mma8652fc;

		// shock-sensor = &shock_sensor;
		shock-sensor = &shock_sensor;

		// Out of standard drivers and declarations
		// TODO: Це треба перенести у відповідний драйвер.
		lte-power = &lte_power;
		lte = &atmodem;

		watchdog0 = &iwdg;
		die-temp0 = &die_temp;
		die-temp1 = &digi_die_temp;
		volt-sensor0 = &vref;
		volt-sensor1 = &vbat;
	};

	ext_flash_mem: memory@90000000 {
		compatible = "zephyr,memory-region";
		reg = <0x90000000 DT_SIZE_M(16)>;
		zephyr,memory-region = "EXT_FLASH";
		/* DT_MEM_ARM_MPU_EXTMEM and DT_MEM_ARM_MPU_FLASH cause MPU issues */
		zephyr,memory-attr = <DT_MEM_ARM_MPU_IO>;
	};

	transceiver1: can-phy1 {
		compatible = "microchip,mcp2562fd", "can-transceiver-gpio";
		standby-gpios = <&gpiob 7 GPIO_ACTIVE_LOW>;
		max-bitrate = <5000000>;
		#phy-cells = <0>;
	};

	transceiver2: can-phy2 {
		compatible = "microchip,mcp2562fd", "can-transceiver-gpio";
		standby-gpios = <&gpioe 0 GPIO_ACTIVE_LOW>;
		max-bitrate = <5000000>;
		#phy-cells = <0>;
	};


	chosen {
		zephyr,console = &uart4;
		zephyr,shell-uart = &uart4;
		zephyr,sram = &sram1;
		// zephyr,code-partition = &code_partition;
		// zephyr,boot-partition = &boot_partition;
		zephyr,canbus = &fdcan2;
		// zephyr,lte = &lte;

		// Use one of WiFi or BLE depend of ESP firmware
		zephyr,bt-hci = &bt_hci_uart;
	};

	leds {
		compatible = "gpio-leds";
		// status = "disabled";
		out_led: led_0 {
			gpios = <&gpioc 9 GPIO_ACTIVE_HIGH>;
			label = "External LED out";
		};
		// Тимчасово зроблю як світлодіод. Хрін знає як прямо визначати GPIO
		lte_power: lte_power {
			gpios = <&gpiod 10 GPIO_ACTIVE_HIGH>;
			label = "LTE_POWER";
		};
	};

	v12v: v12v {
		compatible = "voltage-divider";
		status = "okay";
		io-channels = <&adc1 15>;
		// Cheat! Multiply by 1000 for millivolts is voltage divider sensor output
		full-ohms = <(20000 + 2000)>;
		output-ohms = <2>;
	};

	// v12v: v12v {
	// 	compatible = "voltage-divider";
	// 	status = "okay";
	// 	io-channels = <&eadc 6>;
	// 	// Cheat! Multiply by 1000 for millivolts is voltage divider sensor output
	// 	full-ohms = <(20000 + 2000)>;
	// 	output-ohms = <2>;
	// };

	// shake_sensor: shake_sensor {
	// 	compatible = "voltage-divider";
	// 	status = "okay";
	// 	io-channels = <&eadc 15>;
	// 	// Cheat! Multiply by 1000 for millivolts is voltage divider sensor output
	// 	full-ohms = <1000>;
	// 	output-ohms = <1>;
	// };

	// shock_sensor: shock_sensor {
	// 	compatible = "zephyr,shock-sensor";
	// 	status = "okay";
	// 	// status = "disabled";
	// 	io-channels = <&eadc 15>;
	// 	sampling-period-ms = <2>;
	// 	// sampling-period-ms = <10>;
	// };

	shock_sensor: shock-sensor {
		compatible = "zephyr,shock-sensor";
		status = "okay";
		io-channels = <&adc2 10>;
		sampling-period-ms = <2>;
		// sampling-period-ms = <10>;
	};

	// analog_inputs0: analog-input {
	// 	compatible = "analog-input";
	// 	// poll-period-ms = <32>;
	// 	poll-period-ms = <1000>;

	// 	in1 {
	// 		id = <0>;
	// 		io-channels = <&adc1 11>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in2 {
	// 		id = <1>;
	// 		io-channels = <&adc1 12>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in3 {
	// 		id = <2>;
	// 		io-channels = <&adc1 13>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in4 {
	// 		id = <3>;
	// 		io-channels = <&adc1 0>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in5 {
	// 		id = <4>;
	// 		io-channels = <&adc1 1>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in6 {
	// 		id = <5>;
	// 		io-channels = <&adc1 14>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in7 {
	// 		id = <6>;
	// 		io-channels = <&adc1 19>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in8 {
	// 		id = <7>;
	// 		io-channels = <&adc1 18>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};
	// };

	// analog_inputs0: analog-input {
	// 	compatible = "analog-input";
	// 	// poll-period-ms = <32>;
	// 	poll-period-ms = <100>;

	// 	in1 {
	// 		id = <0>;
	// 		io-channels = <&eadc 14>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in2 {
	// 		id = <1>;
	// 		io-channels = <&eadc 13>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in3 {
	// 		id = <2>;
	// 		io-channels = <&eadc 12>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in4 {
	// 		id = <3>;
	// 		io-channels = <&eadc 11>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in5 {
	// 		id = <4>;
	// 		io-channels = <&eadc 10>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in6 {
	// 		id = <5>;
	// 		io-channels = <&eadc 9>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	// TODO: Я спеціально поміняв місцями два останніх канали,
	// 	// щоб перевірити чи правильно буде працювати індексація
	// 	in8 {
	// 		id = <7>;
	// 		io-channels = <&eadc 7>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};

	// 	in7 {
	// 		id = <6>;
	// 		io-channels = <&eadc 8>;
	// 		r_top = <1100>;
	// 		r_bottom = <200>;
	// 	};
	// };

	zephyr,user {
		// compatible = "gpio-output";

		// Outputs
		out-1-gpios = <&gpioc 5 GPIO_ACTIVE_HIGH>;	// 1. Сирена
		out-2-gpios = <&gpioc 4 GPIO_ACTIVE_HIGH>;	// 2. Аварійка
		out-3-gpios = <&gpioe 5 GPIO_ACTIVE_HIGH>;	// 3. Закривання ЦЗ
		out-4-gpios = <&gpioc 13 GPIO_ACTIVE_HIGH>;	// 4. Відкривання ЦЗ
		out-5-gpios = <&gpioe 6 GPIO_ACTIVE_HIGH>;	// 5. Відкривання багажника
		out-6-gpios = <&gpioe 4 GPIO_ACTIVE_HIGH>;	// 6. Старт/Стоп
		out-7-gpios = <&gpioe 3 GPIO_ACTIVE_HIGH>;	// 7. НЗБД
		out-8-gpios = <&gpioe 2 GPIO_ACTIVE_HIGH>;	// 8. Канал 1
	};


	// fstab {
	// 	compatible = "zephyr,fstab";
	// 	lfs1: lfs1 {
	// 		compatible = "zephyr,fstab,littlefs";
	// 		read-size = <1>;
	// 		prog-size = <16>;
	// 		cache-size = <256>;
	// 		lookahead-size = <32>;
	// 		block-cycles = <512>;
	// 		partition = <&littlefs_partition>;
	// 		mount-point = "/lfs1";
	// 	};
	// };

	// gpio_keys {
	// 	compatible = "gpio-keys";
	// 	user_button_1: button_1 {
	// 		label = "User SW2";
	// 		gpios = <&gpioh 1 GPIO_ACTIVE_LOW>;
	// 		zephyr,code = <INPUT_KEY_0>;
	// 	};
	// 	user_button_2: button_2 {
	// 		label = "User SW3";
	// 		gpios = <&gpioh 0 GPIO_ACTIVE_LOW>;
	// 		zephyr,code = <INPUT_KEY_1>;
	// 	};
	// };
};

&clk_hse {
	clock-frequency = <DT_FREQ_M(8)>; /* STLink 8MHz clock */
	// hse-bypass;
	status = "okay";
};

&clk_hsi48 {
	status = "okay";
	// crs-usb-sof;
};

&clk_lse {
	status = "okay";
};

// PLL take 128...560MHz
&pll {
	div-m = <2>;	// 8MHx / 2 = 4MHz
	mul-n = <120>;	// 4MHz * 120 = 480MHz
	div-p = <2>;	// 480MHz / 2 = 240MHz (->SYSCLK)
	div-q = <3>;	// 480MHz / 3 = 160MHz (->FDCAN,...? old)
	div-r = <2>;	// 480MHz / 2 = 80MHz
	clocks = <&clk_hse>;	// HSE = 8MHz
	status = "okay";
};

&pll2 {
	div-m = <2>;
	mul-n = <120>;
	div-p = <2>;
	div-q = <3>;	// 160MHz -> FDCAN
	div-r = <2>;
	clocks = <&clk_hse>;
	status = "okay";
};

&rcc {
	clocks = <&pll>;
	clock-frequency = <DT_FREQ_M(240)>;
	ahb-prescaler = <1>;
	apb1-prescaler = <2>;
	apb2-prescaler = <1>;
	apb3-prescaler = <2>;
};

&rtc {
	clocks = <&rcc STM32_CLOCK(APB3, 21)>,
		 <&rcc STM32_SRC_LSE RTC_SEL(1)>;
	status = "okay";
};

&iwdg {
	status = "okay";
};

&gpdma1 {
	status = "okay";
};

&gpdma2 {
	status = "okay";
};

zephyr_udc0: &usb {
	pinctrl-0 = <&usb_dm_pa11 &usb_dp_pa12>;
	pinctrl-names = "default";
	status = "okay";
};




//&usb {
//	status = "okay";
/*	usb_cdc@0 {
		compatible = "usb,usb_cdc";
		status = "okay";
	};
*/
//};

&fdcan1 {
	pinctrl-0 = <&fdcan1_rx_pb8 &fdcan1_tx_pb9>;
	pinctrl-names = "default";
	// clocks = <&rcc STM32_CLOCK(APB1_2, 9)>,
	// 	 <&rcc STM32_SRC_PLL1_Q FDCAN_SEL(1)>;
	clocks = <&rcc STM32_CLOCK(APB1_2, 9)>,
		 <&rcc STM32_SRC_PLL2_Q FDCAN_SEL(2)>;
	clk-divider = <1>;	// 160MГц / clk-divider
	phys = <&transceiver1>;
	// bitrate = <500000>;
	// sample-point = <875>;
	status = "okay";

	/* Перший CAN починається з 0x0.
	   Формат: <offset std_filt ext_filt rx0 rx1 rx_buf tx_evt tx_buf> */
	// bosch,mram-cfg = <0x0 28 8 3 3 0 3 3>;
};

&fdcan2 {
	pinctrl-0 = <&fdcan2_rx_pb5 &fdcan2_tx_pb6>;
	pinctrl-names = "default";
	// clocks = <&rcc STM32_CLOCK(APB1_2, 9)>,
	// 	 <&rcc STM32_SRC_PLL1_Q FDCAN_SEL(1)>;
	clocks = <&rcc STM32_CLOCK(APB1_2, 9)>,
		 <&rcc STM32_SRC_PLL2_Q FDCAN_SEL(2)>;
	clk-divider = <1>;  // 160MГц / clk-divider
	phys = <&transceiver2>;
	// bitrate = <500000>;
	// sample-point = <875>;
	status = "okay";
	/* Другий CAN має починатися після того, як закінчиться пам'ять першого.
	   Конфігурація вище займає приблизно 848 байт.
	   Зміщення 0x400 (1024 байти) — це безпечний варіант із запасом. */
	// bosch,mram-cfg = <0x400 28 8 3 3 0 3 3>;
};


// &eadc {
// 	#address-cells = <1>;
// 	#size-cells = <0>;
// 	status = "okay";

// 	// &eadc_pb14	/* In1. Запалювання */
// 	channel@14 {
// 		reg = <14>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb13	/* In2. Капот */
// 	channel@13 {
// 		reg = <13>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb12	/* In3. PIN */
// 	channel@12 {
// 		reg = <12>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb11	/* In4. Парковка */
// 	channel@11 {
// 		reg = <11>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb10	/* In5. Тормоз */
// 	channel@10 {
// 		reg = <10>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb9	/* In6. Мастило */
// 	channel@9 {
// 		reg = <9>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb8	/* In7. Ручка */
// 	channel@8 {
// 		reg = <8>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb7	/* In8. Дозвіл/Резервне живлення */
// 	channel@7 {
// 		reg = <7>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb6	/* +12V Основне живлення */
// 	channel@6 {
// 		reg = <6>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// &eadc_pb15	/* Датчик удару */
// 	channel@15 {
// 		reg = <15>;
// 		zephyr,gain = "ADC_GAIN_1";
// 		zephyr,reference = "ADC_REF_INTERNAL";
// 		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 		zephyr,resolution = <12>;
// 		// zephyr,oversampling = <0>;
// 		zephyr,vref-mv = <3300>;
// 	};

// 	// // 	// vref-internal-mv = <3000>;
// 	pinctrl-0 = <
// 		&eadc_pb14	/* In1. Запалювання */
// 		&eadc_pb13	/* In2. Капот */
// 		&eadc_pb12	/* In3. PIN */
// 		&eadc_pb11	/* In4. Парковка */
// 		&eadc_pb10	/* In5. Тормоз */
// 		&eadc_pb9	/* In6. Мастило */
// 		&eadc_pb8	/* In7. Ручка */
// 		&eadc_pb7	/* In8. Дозвіл/Резервне живлення */
// 		&eadc_pb6	/* +12V Основне живлення */
// 		&eadc_pb15	/* Датчик удару */
// 	>;
// 	pinctrl-names = "default";

// // 	#address-cells = <1>;
// // 	#size-cells = <0>;
// // 	vref-internal-mv = <3000>;

// 	// channel@14 {
// 	// 	reg = <14>;
// 	// 	zephyr,gain = "ADC_GAIN_1";
// 	// 	zephyr,reference = "ADC_REF_INTERNAL";
// 	// 	zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
// 	// 	zephyr,resolution = <12>;
// 	// 	zephyr,vref-mv = <3000>;
// 	// 	// label = "In1. Запалювання";

// 	// };
// };

// &spi2 {
// 	status = "okay";
// 	pinctrl-0 = <&spi2_pa9_pa8_pa10>;
// 	pinctrl-names = "default";
// 	cs-gpios = <&gpioa 11 GPIO_ACTIVE_LOW>;

// 	spi2_flash: w25q128@0 {
// 		// compatible = "winbond,w25q128";
// 		compatible = "jedec,spi-nor";
// 		size = <(16*1024*1024)>;
// 		reg = <0>;
// 		spi-max-frequency = <1000000>;
// 		// clk-frequency = <25000000>;
// 		jedec-id = [ef 40 18];		// W25Q128JV-IN/IQ/JQ = 0xEF 40 18
// 									// W25Q128JV-IM*/JM* = 0xEF 70 18
// 		status = "okay";

// 		partitions {
// 			compatible = "fixed-partitions";
// 			#address-cells = <1>;
// 			#size-cells = <1>;

// 			/* This is the littlefs v1 file system pre-installed
// 		 	* by Particle.
// 		 	*/
// 			littlefs_partition: partition@0 {
// 				label = "littlefs";
// 				reg = <0x00000000 DT_SIZE_M(8)>;	// Eah! Half of entire memory.
// 			};

// 			/* 1MB partition to use for raw data storage. */
// 			storage_partition: partition@800000 {
// 				label = "storage";
// 				reg = <DT_SIZE_M(8) DT_SIZE_M(1)>;
// 			};

// 			/* 7MB partition for GPS-buffer data. */
// 			gps_partition: partition@900000 {
// 				label = "gps";
// 				reg = <DT_SIZE_M(8) DT_SIZE_M(7)>;
// 			};


// 		};
// 	};
// };

// &i2c1 {
// 	status = "okay";
// 	pinctrl-0 = <&i2c1_pa7_pa6>;
// 	pinctrl-names = "default";

// 	// Int on PC6/INT2
// 	mma8652fc: mma8652fc@1d {
// 		compatible = "nxp,fxos8700","nxp,mma8652fc";
// 		reg = <0x1d>;
// 		int1-gpios = <&gpioc 6 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
// 		// interrupt-parent = <&gpioc>;
// 		// interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
// 	};
// };

// // &scc {
// // 	/* For USB 1.1 Host/Device/OTG, configure to 192MHz, which can generate necessary 48MHz. */
// // 	/* For USB 2.0 Host/Device/OTG or no USB application, comment out to use default. */
// // 	// core-clock = <192000000>;
// // 	core-clock = <4000000>;
// // };

&gpioa {
	status = "okay";
};

&gpiob {
	status = "okay";
};

&gpioc {
	status = "okay";
};

&gpiod {
	status = "okay";
};

&gpioe {
	status = "okay";
};

&gpioh {
	status = "okay";
};



// &uart3 {
// 	current-speed = <115200>;
// 	pinctrl-0 = <&uart3_pc2_pc3>;
// 	pinctrl-names = "default";
// 	status = "okay";
// };

// Used for console and logging
&uart4 {
	pinctrl-0 = <&uart4_tx_pc10 &uart4_rx_pc11>;
	pinctrl-names = "default";
	current-speed = <115200>;
	status = "okay";
};

// Maybe will be used for ESP32 flashing
&usart1 {
	pinctrl-0 = <&usart1_tx_pa9 &usart1_rx_pa10>;
	pinctrl-names = "default";
	current-speed = <115200>;
	//status = "okay";
};


// Used for LIN
&uart12 {
	pinctrl-0 = <&uart12_tx_pe10 &uart12_rx_pe9>;
	pinctrl-names = "default";
	current-speed = <19200>;
	//status = "okay";
	// TODO: https://github.com/dragonlock2/zephyrboards/blob/main/boards/others/stm32_esc/stm32_esc.dts
    lin0: lin0 {
        compatible = "virtual,lin-uart";
        status = "okay";
        bitrate = <19200>;
        max-wait-percent = <200>;
    };
};


// Used for BLE (AT?)
&uart9 {
	pinctrl-0 = <&uart9_tx_pd15 &uart9_rx_pd14 &uart9_cts_pd0 &uart9_rts_pd13>;
	pinctrl-names = "default";
	current-speed = <115200>;
	hw-flow-control;
	status = "okay";
	/*
	esp_wifi: esp-wifi {
		compatible = "espressif,esp-at";
		// power-gpios = <&gpiod 4 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		power-gpios = <&gpiod 4 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		status = "okay";
	};
	*/
	bt_hci_uart: bt_hci_uart {
		compatible = "zephyr,bt-hci-uart";
		status = "okay";
		reset-gpios = <&gpioc 12 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;

		// da1453x {
		// 	compatible = "renesas,bt-hci-da1453x";
		// 	reset-gpios = <&mikrobus_header 1 GPIO_ACTIVE_HIGH>;
		// 	status = "okay";
		// };
	};
};


// Used for LTE (cellular modem)
&usart3 {
	pinctrl-0 = <&usart3_tx_pd8 &usart3_rx_pd9 &usart3_cts_pd11 &usart3_rts_pd12>;
	pinctrl-names = "default";
	current-speed = <115200>;
	hw-flow-control;
	status = "okay";
	// modem: modem {
	// 	compatible = "simcom,a76xx";
	// 	// power-gpios = <&gpiod 4 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
	// 	// mdm-vbat-gpios = <&gpiod 10 (GPIO_ACTIVE_HIGH)>;	// Main power
	// 	mdm-power-gpios = <&gpioa 15 (GPIO_ACTIVE_HIGH)>;	// PWRKEY. Not is POWER
	// 	mdm-wake-gpios = <&gpiod 1 (GPIO_ACTIVE_HIGH)>;		// ~DTR
	// 	// mdm-status-gpios = <&gpioc 8 (GPIO_ACTIVE_HIGH)>;	// STATUS
	// 	status = "okay";
	// };
	atmodem: atmodem {
		compatible = "simcom,a76xx-at";
		// power-gpios = <&gpiod 4 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		mdm-vbat-gpios = <&gpiod 10 (GPIO_ACTIVE_HIGH)>;	// Main power
		mdm-power-gpios = <&gpioa 15 (GPIO_ACTIVE_HIGH)>;	// PWRKEY. Not is POWER
		mdm-wake-gpios = <&gpiod 1 (GPIO_ACTIVE_HIGH)>;		// ~DTR
		mdm-status-gpios = <&gpioc 8 (GPIO_ACTIVE_HIGH)>;	// STATUS
		status = "okay";
	};
};


&spi4 {
	pinctrl-0 = <&spi4_sck_pe12 &spi4_miso_pe13 &spi4_mosi_pe14>;
	pinctrl-names = "default";
	cs-gpios = <&gpioe 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "okay";

	lis2dw12: lis2dw12@0 {
		compatible = "st,lis2dw12";
		status = "okay";
		spi-max-frequency = <1000000>;
		reg = <0>;
		irq-gpios = <&gpiob 10 GPIO_ACTIVE_HIGH>;
		int-pin = <1>;
	};

};

&xspi1 {
	pinctrl-0 = <&octospi1_io0_pb1 &octospi1_io1_pb0
		     &octospi1_io2_pa7 &octospi1_io3_pa6
		     &octospi1_clk_pb2 &octospi1_ncs_pe11>;
	pinctrl-names = "default";
	status = "okay";
};

// &uart5 {
// 	current-speed = <115200>;
// 	pinctrl-0 = <&uart5_pa4_pa5>;
// 	pinctrl-names = "default";
// 	status = "okay";

// 	gsm: gsm-modem {
// 		compatible = "simcom,a7682e";
// 		label = "SIMCOM A7682E";

// 		/*status-gpios = <&portb 12 GPIO_ACTIVE_LOW>; */

// 		status-gpios = <&gpioc 7 GPIO_ACTIVE_HIGH>;
// 		dtr-gpios = <&gpioa 2 GPIO_ACTIVE_HIGH>;
// 		pwrkey-gpios = <&gpiof 4 GPIO_ACTIVE_HIGH>;
// 		power-gpios = <&gpioa 3 GPIO_ACTIVE_HIGH>;
// 	};

// };

// &canfd0 {
// 	bus-speed = <125000>;
// 	bus-speed-data = <1000000>;
// 	pinctrl-0 = <&canfd0_default>;
// 	pinctrl-names = "default";
// 	status = "okay";
// };

// &emac {
// 	pinctrl-0 = <&emac_default>;
// 	pinctrl-names = "default";
// 	status = "okay";
// };

&aes {
	status = "okay";
};

&rng {
	status = "okay";
};


// For low-power tick source

stm32_lp_tick_source: &lptim4 {
	clocks = <&rcc STM32_CLOCK(APB3, 13)>,
		 <&rcc STM32_SRC_LSI LPTIM4_SEL(4)>;
	status = "okay";
};

&die_temp {
	status = "okay";
};

&digi_die_temp {
	status = "okay";
};

&vref {
	status = "okay";
};
